;;; 80 characters wide please ;;;;;;;;;;;;;;;;;;;;;;;;;; 8-space tabs please ;;;


;
;;;
;;;;;  TashFloppy Transmitter
;;;
;


;;; Connections ;;;

;See pinout.py in parent directory for pin assignments


;;; Assembler Directives ;;;

	list		P=PIC16F1704, F=INHX32, ST=OFF, MM=OFF, R=DEC, X=ON
	#include	P16F1704.inc
	errorlevel	-302	;Suppress "register not in bank 0" messages
	errorlevel	-224	;Suppress TRIS instruction not recommended msgs
	__config	_CONFIG1, _FOSC_INTOSC & _WDTE_OFF & _PWRTE_ON & _MCLRE_OFF & _CP_OFF & _BOREN_OFF & _CLKOUTEN_OFF & _IESO_OFF & _FCMEN_OFF
			;_FOSC_INTOSC	Internal oscillator, I/O on RA5
			;_WDTE_OFF	Watchdog timer disabled
			;_PWRTE_ON	Keep in reset for 64 ms on start
			;_MCLRE_OFF	RA3/!MCLR is RA3
			;_CP_OFF	Code protection off
			;_BOREN_OFF	Brownout reset off
			;_CLKOUTEN_OFF	CLKOUT disabled, I/O on RA4
			;_IESO_OFF	Internal/External switch not needed
			;_FCMEN_OFF	Fail-safe clock monitor not needed
	__config	_CONFIG2, _WRT_OFF & _PPS1WAY_OFF & _ZCDDIS_ON & _PLLEN_ON & _STVREN_ON & _LVP_OFF
			;_WRT_OFF	Write protection off
			;_PPS1WAY_OFF	PPS can change more than once
			;_ZCDDIS_ON	Zero crossing detector disabled
			;_PLLEN_ON	4x PLL on
			;_STVREN_ON	Stack over/underflow causes reset
			;_LVP_OFF	High-voltage on Vpp to program


;;; Macros ;;;

DELAY	macro	value		;Delay 3*W cycles, set W to 0
	movlw	value
	decfsz	WREG,F
	bra	$-1
	endm

DNOP	macro
	bra	$+1
	endm


;;; Pin Assignments ;;;

	#include	transmitter_pinout.inc	;Generated by pinout.py


;;; Constants ;;;

;FLAGS:
NDIRTN	equ	7	;Set when track number decreases on step (toward rim)
LASTLSB	equ	6	;Set if last MFM byte had LSb set
MFMLIT	equ	5	;Set if MFM byte is to be interpreted literally

;GCR tachometer parameters:
TACHFCV	equ	156	;Feathering period, in units of 4.096 ms
RPMDEV	equ	1	;Feathering deviation, in units of 0.4%
Z0RPM	equ	394	;RPM in speed zone 0 (tracks 0-15)
Z1RPM	equ	429	;RPM in speed zone 1 (tracks 16-31)
Z2RPM	equ	472	;RPM in speed zone 2 (tracks 32-47)
Z3RPM	equ	525	;RPM in speed zone 3 (tracks 48-63)
Z4RPM	equ	590	;RPM in speed zone 4 (tracks 64-79)


;;; Variable Storage ;;;

	cblock	0x70	;Bank-common registers
	
	FLAGS	;You've got to have flags
	TRACK	;Current track where head is placed
	TACHFSH	;Tachometer feather swap value; swapped with CCP register value
	TACHFSL	; at intervals
	TACHFCH	;Tachometer feather count-up timer; when over limit, it swaps
	TACHFCL	; the CCP register with TACHFSH:L
	INDXCNT	;Countdown of 5 ms periods to index pulse
	X8
	X7
	X6
	X5
	X4
	X3
	X2	;Various purposes
	X1	; "
	X0	; "
	
	endc


;;; Vectors ;;;

	org	0x0		;Reset vector
	movlp	high Init
	goto	Init

	org	0x4		;Interrupt vector
	;fall through


;;; Interrupt Handler ;;;

Interrupt
	movlb	0		;Grab the command port as early as possible in
	movf	CMD_PORT,W	; case CA3 was pulsed
	movlb	7		;If CA3 was pulsed, handle it
	btfsc	CA3_IOCF,CA3_PIN; "
	call	IntCa3		; "
	movlb	7		;If !WRREQ changed state, handle it
	btfsc	NWQ_IOCF,NWQ_PIN; "
	call	IntNwrreq	; "
	movlb	0		;If Timer2 has interrupted, handle it
	btfsc	PIR1,TMR2IF	; "
	call	IntIndex	; "
	retfie			;Done

IntNwrreq
	bcf	NWQ_IOCF,NWQ_PIN;Clear the interrupt
	movlb	0		;If !ENBL is high, this !WRREQ change is not for
	btfsc	NEN_PORT,NEN_PIN; us, so return
	return			; "
	movlb	30		;If MFMMODE is not high, we don't need to do
	btfss	CLC1GLS2,7	; anything
	return			; "
	movlb	0		;If !WRREQ is now low, skip ahead
	btfss	NWQ_PORT,NWQ_PIN; "
	bra	IntNwrreqFalling; "
	;fall through		;Else fall through

IntNwrreqRising
	movlb	30		;Set output of CLC1 when CA0 is low to be
	movlw	B'10010';SDO	; determined by SSP
	movwf	CLC1SEL0	; "
	movlw	B'00000101'	; "
	movwf	CLC1GLS0	; "
	movlb	0		;Reset and stop Timer2
	bcf	T2CON,TMR2ON	; "
	clrf	TMR2		; "
	bcf	PIR1,TMR2IF	; "
	return			;Done

IntNwrreqFalling
	movlb	30		;Set output of CLC1 when CA0 is low to be
	movlw	B'01100';CCP1	; determined by CCP1
	movwf	CLC1SEL0	; "
	movlw	B'00000010'	; "
	movwf	CLC1GLS0	; "
	movlw	4		;Set the index pulse countdown to 20 ms, that's
	movwf	INDXCNT		; soon but well beyond a single sector's write
	movlb	0		;Reset and start Timer2
	bcf	PIR1,TMR2IF	; "
	clrf	TMR2		; "
	bsf	T2CON,TMR2ON	; "
	return			;Done

IntCa3
	bcf	CA3_IOCF,CA3_PIN;Clear the interrupt
	movlb	0		;If !ENBL is high, this CA3 pulse is not for us,
	btfsc	NEN_PORT,NEN_PIN; so return
	return			; "
	callw			;Translate the command port read into a command
	movlb	30		;Switch to CLC bank, common need among commands
	brw			;CA2 CA1 CA0 SEL Effect
	bra	IntCa3DirtnLow	;0   0   0   0   Set !DIRTN low
	return			;0   0   0   1   none
	bra	IntCa3Step	;0   0   1   0   Step drive heads
	bra	IntCa3MfmMode	;0   0   1   1   Select MFM mode
	return			;0   1   0   0   Turn motor on (ignore)
	return			;0   1   0   1   none
	return			;0   1   1   0   none
	return			;0   1   1   1   none
	bra	IntCa3DirtnHigh	;1   0   0   0   Set !DIRTN high
	return			;1   0   0   1   Reset SWITCHED to low (ignore)
	return			;1   0   1   0   none
	bra	IntCa3GcrMode	;1   0   1   1   Select GCR mode
	return			;1   1   0   0   Turn motor off (ignore)
	return			;1   1   0   1   none
	bra	IntCa3Eject	;1   1   1   0   Eject disk
	return			;1   1   1   1   none

IntCa3DirtnLow
	bcf	FLAGS,NDIRTN	;Set internal !DIRTN flag low
	return			;Done

IntCa3Step
	bsf	CLC2GLS0,7	;Set !READY high
	btfsc	FLAGS,NDIRTN	;If !DIRTN is high (decrement track, toward
	bra	ICStep0		; rim), skip ahead
	incf	TRACK,F		;Increment track
	movf	TRACK,W		;If we hit track 80, go back to 79
	xorlw	80		; "
	btfsc	STATUS,Z	; "
	decf	TRACK,F		; "
	return			;Done
ICStep0	movf	TRACK,W		;If track is not already 0, decrement it
	btfss	STATUS,Z	; "
	decf	TRACK,F		; "
	return			;Done

IntCa3MfmMode
	bsf	CLC1GLS2,7	;Set MFMMODE high
	return			;Done

IntCa3DirtnHigh
	bsf	FLAGS,NDIRTN	;Set internal !DIRTN flag high
	return			;Done

IntCa3GcrMode
	bcf	CLC1GLS2,7	;Set MFMMODE low
	return			;Done

IntCa3Eject
	btfsc	CLC1GLS2,6	;If SUPERDRIVE is high, set PRESENT/!HD low
	bcf	CLC2GLS2,7	; "
	return			;Done

IntIndex
	bcf	PIR1,TMR2IF	;Clear the interrupt
	decfsz	INDXCNT,F	;Decrement the index countdown and proceed only
	return			; when it hits zero
	movlb	0		;Reset Timer1
	clrf	T1CON		; "
	clrf	TMR1H		; "
	clrf	TMR1L		; "
	bsf	T1CON,TMR1ON	; "
	movlb	5		;Set CCP1 to go high now and go low when 2.048
	movlw	B'00001001'	; ms elapse, as SetupForMfm prepared
	clrf	CCP1CON		; "
	movwf	CCP1CON		; "
	movlb	30		;Set the index pulse countdown to measure 200 ms
	movlw	40		; (300 RPM) for a high density disk and 100 ms
	btfsc	CLC2GLS2,7	; (600 RPM) for a double density disk
	movlw	20		; "
	movwf	INDXCNT		; "
	return			;Done


;;; Hardware Initialization ;;;

Init
	banksel	OSCCON		;32 MHz (w/PLL) high-freq internal oscillator
	movlw	B'11110000'
	movwf	OSCCON

	banksel	RCSTA		;UART async mode, 1 MHz, receiver not enabled
	movlw	B'01001000'	; just yet, transmitter not enabled at all
	movwf	BAUDCON
	clrf	SPBRGH
	movlw	7
	movwf	SPBRGL
	movlw	B'00000100'
	movwf	TXSTA
	movlw	B'10000000'
	movwf	RCSTA

	banksel	SSPCON1		;SSP SPI master mode, clock set by baud rate
	movlw	B'00101010'	; generator, clock idles low, data lines change
	movwf	SSPCON1		; on rising edge, data sampled on rising edge
	clrf	SSP1STAT	; (CKP=0, CKE=0, SMP=0)

	banksel	CLC1CON		;CLC1 in RDDATA mode (when !WRREQ is high or
	movlw	B'10010';SDO	; MFMMODE is low):
	movwf	CLC1SEL0	;If CLCIN2 (CA0) is low, output is SDO NAND SCK
	movlw	B'10000';SCK	;If CLCIN2 (CA0) is high, output is:
	movwf	CLC1SEL1	; SUPERDRIVE  MFMMODE    Output   CLC1GLS2
	movlw	B'00010';CLCIN2	; (SEL low)   (SEL high)
	movwf	CLC1SEL2; (CA0)	; 0           0          0        00000000 (def)
	movlw	B'00011';CLCIN3	; 0           1          SEL      10000000
	movwf	CLC1SEL3; (SEL)	; 1           0          NOT SEL  01000000
	movlw	B'00000101'	; 1           1          1        11000000
	movwf	CLC1GLS0
	movlw	B'00010000'	;CLC1 in INDEX mode (when !WRREQ is low and
	movwf	CLC1GLS1	; MFMMODE is high):
	clrf	CLC1GLS2	;If CLCIN2 (CA0) is low, output is CLCIN0 (CCP1
	movlw	B'00100000'	; from tachometer)
	movwf	CLC1GLS3	;If CLCIN2 (CA0) is high, output is as above
	clrf	CLC1POL
	movlw	B'10000000'
	movwf	CLC1CON		;CLC2:
	movlw	B'00010';CLCIN2	;If CLCIN2 (CA0) is low, output is:
	movwf	CLC2SEL2; (CA0)	; SIDES      !READY      Output   CLC2GLS0
	movlw	B'00011';CLCIN3	; (SEL low)  (SEL high)
	movwf	CLC2SEL3; (SEL)	; 0          0           0        00000000
	movlw	B'11000000'	; 0          1           SEL      10000000
	movwf	CLC2GLS0	; 1          0           NOT SEL  01000000
	movlw	B'00010000'	; 1          1           1        11000000 (def)
	movwf	CLC2GLS1	;If CLCIN2 (CA0) is high, output is:
	movlw	B'11000000'	; !DRVIN     PRESENT/!HD Output   CLC2GLS2
	movwf	CLC2GLS2	; (SEL low)  (SEL high)
	movlw	B'00100000'	; 0          0           0        00000000
	movwf	CLC2GLS3	; 0          1           SEL      10000000
	clrf	CLC2POL		; 1          0           NOT SEL  01000000
	movlw	B'10000000'	; 1          1           1        11000000 (def)
	movwf	CLC2CON
	movlw	B'00001';CLCIN1	;CLC3:
	movwf	CLC3SEL1; (CA1)	;If CLCIN1 (CA1) is low, output is LC1OUT
	movlw	B'00100';LC1OUT	;If CLCIN1 (CA1) is high, output is LC2OUT
	movwf	CLC3SEL2
	movlw	B'00101';LC2OUT
	movwf	CLC3SEL3
	movlw	B'00100000'
	movwf	CLC3GLS0
	movlw	B'00000100'
	movwf	CLC3GLS1
	movlw	B'10000000'
	movwf	CLC3GLS2
	movlw	B'00001000'
	movwf	CLC3GLS3
	clrf	CLC3POL
	movlw	B'10000000'
	movwf	CLC3CON

	banksel	FVRCON		;Temperature sensor on so ADC can use it as part
	movlw	B'00110000'	; of a pseudorandom number generator
	movwf	FVRCON

	banksel	ADCON0		;ADC on, right justified, temperature sensor
	movlw	B'11000000'	; selected, auto-start a conversion every time
	movwf	ADCON2		; Timer4 matches
	movlw	B'10100000'
	movwf	ADCON1
	movlw	B'01110101'
	movwf	ADCON0

	banksel	T6CON		;Timer6 ticks 1:1 with instruction clock, period
	movlw	B'00000100'	; set so it doesn't get synced with SSP
	movwf	T6CON
	movlw	254
	movwf	PR6

	banksel	T4CON		;Timer4 ticks 1:1 with instruction clock, period
	movlw	B'00000100'	; set so ADC reads once every 128 cycles
	movwf	T4CON
	movlw	127
	movwf	PR4

	banksel	T2CON		;Timer2 ticks 1:16 with instruction clock when
	movlw	B'01001010'	; running but not started yet, period and post-
	movwf	T2CON		; scaler set so it interrupts once every 40,000
	movlw	250		; cycles (5 ms)
	movwf	PR2

	banksel	IOCAP		;CA3 interrupts on rising edge, !WRREQ on either
	bsf	CA3_IOCP,CA3_PIN
	bsf	NWQ_IOCP,NWQ_PIN
	bsf	NWQ_IOCN,NWQ_PIN

	banksel	ANSELA		;All pins digital, not analog
	clrf	ANSELA
	clrf	ANSELC

	banksel	INLVLA		;All inputs TTL, not ST
	clrf	INLVLA
	clrf	INLVLC

	banksel	RA0PPS		;Set up PPS outputs
	movlw	B'00110';LC3OUT
	movwf	CTD_PPS
	movlw	B'01100';CCP1
	movwf	TTD_PPS

	banksel	CKPPS		;Set up PPS inputs
	movlw	CA1_PPSI
	movwf	CLCIN1PPS
	movlw	CA0_PPSI
	movwf	CLCIN2PPS
	movlw	SEL_PPSI
	movwf	CLCIN3PPS
	movlw	RX_PPSI
	movwf	RXPPS
	movlw	TTD_PPSI
	movwf	CCP1PPS

	banksel	LATA		;CTS high (unasserted) so host waits to send
	bsf	CTS_PORT,CTS_PIN

	banksel	TRISA		;LC3OUT, CTS, CCP1 outputs, all others inputs
	bcf	CTD_PORT,CTD_PIN
	bcf	CTS_PORT,CTS_PIN
	bcf	TTD_PORT,TTD_PIN

	banksel	PIE1		;Timer2 interrupt enabled
	movlw	1 << TMR2IE
	movwf	PIE1

	movlw	0x20		;Point queue pop (FSR0) and push (FSR1) pointers
	movwf	FSR0H		; to first 256 bytes of linear memory
	movwf	FSR1H
	clrf	FSR0L
	clrf	FSR1L

	movlp	7		;Initialize key globals
	clrf	FLAGS
	clrf	TRACK

	banksel	OSCSTAT		;Spin until PLL is ready and instruction clock
	btfss	OSCSTAT,PLLR	; gears up to 8 MHz
	bra	$-1

	banksel	RCSTA		;Enable receiver now that PLL is ready
	bsf	RCSTA,CREN

	banksel	LATA		;CTS low (asserted) so host sends data
	bcf	CTS_PORT,CTS_PIN

	movlw	B'11001000'	;Interrupt subsystem, peripheral interrupts (for
	movwf	INTCON		; Timer2) and interrupt-on-change interrupts on

	;fall through


;;; Mainline ;;;

WaitCommand
	movlb	0		;Spin until a byte comes in over the UART
	btfss	PIR1,RCIF	; "
	bra	$-1		; "
	movlb	3		;Grab the received byte and store it to
	movf	RCREG,W		; reference later
	movwf	X0		; "
	swapf	X0,W		;Switch off based on the high nibble of the
	andlw	B'00001111'	; command byte
	brw			; "
	bra	WaitCommand	;0x0? - invalid
	bra	WaitCommand	;0x1? - invalid
	bra	WaitCommand	;0x2? - invalid
	bra	WaitCommand	;0x3? - invalid
	bra	WaitCommand	;0x4? - invalid
	bra	WaitCommand	;0x5? - invalid
	bra	WaitCommand	;0x6? - invalid
	bra	WaitCommand	;0x7? - invalid
	bra	WaitCommand	;0x8? - invalid
	bra	WaitCommand	;0x9? - invalid
	bra	WaitCommand	;0xA? - invalid
	bra	WaitCommand	;0xB? - invalid
	bra	HwConfig	;0xC? - hardware configuration
	bra	InsertDisk	;0xD? - insert disk
	bra	DataMode	;0xE? - enter data mode
	bra	WaitCommand	;0xF? - invalid

HwConfig
	movf	X0,W		;Switch off based on the low nibble of the
	andlw	B'00001111'	; command byte
	brw			; "
	bra	HwConfigNoDrive	;0xC0 - no drive
	bra	HwConfig400k	;0xC1 - 400k drive
	bra	HwConfig800k	;0xC2 - 800k drive
	bra	HwConfigSuper	;0xC3 - superdrive
	bra	WaitCommand	;0xC4 - invalid
	bra	WaitCommand	;0xC5 - invalid
	bra	WaitCommand	;0xC6 - invalid
	bra	WaitCommand	;0xC7 - invalid
	bra	WaitCommand	;0xC8 - invalid
	bra	WaitCommand	;0xC9 - invalid
	bra	WaitCommand	;0xCA - invalid
	bra	WaitCommand	;0xCB - invalid
	bra	WaitCommand	;0xCC - invalid
	bra	WaitCommand	;0xCD - invalid
	bra	WaitCommand	;0xCE - invalid
	bra	WaitCommand	;0xCF - invalid

InsertDisk
	movf	X0,W		;Switch off based on the low nibble of the
	andlw	B'00001111'	; command byte
	brw			; "
	bra	InsertDiskHdRo	;0xD0 - insert HD disk, read-only
	bra	InsertDiskHdRw	;0xD1 - insert HD disk, read-write
	bra	InsertDiskDdRo	;0xD2 - insert DD disk, read-only
	bra	InsertDiskDdRw	;0xD3 - insert DD disk, read-write
	bra	WaitCommand	;0xD4 - invalid
	bra	WaitCommand	;0xD5 - invalid
	bra	WaitCommand	;0xD6 - invalid
	bra	WaitCommand	;0xD7 - invalid
	bra	WaitCommand	;0xD8 - invalid
	bra	WaitCommand	;0xD9 - invalid
	bra	WaitCommand	;0xDA - invalid
	bra	WaitCommand	;0xDB - invalid
	bra	WaitCommand	;0xDC - invalid
	bra	WaitCommand	;0xDD - invalid
	bra	WaitCommand	;0xDE - invalid
	bra	InsertDiskEject	;0xDF - force eject disk

DataMode
	movf	X0,W		;Switch off based on the low nibble of the
	andlw	B'00001111'	; command byte
	brw			; "
	goto	DataModeAutoGcr	;0xE0 - auto GCR
	goto	DataModeRawGcr	;0xE1 - raw GCR with random noise
	bra	WaitCommand	;0xE2 - invalid
	bra	WaitCommand	;0xE3 - invalid
	goto	DataModeAutoMfm	;0xE4 - auto MFM
	bra	WaitCommand	;0xE5 - invalid
	bra	WaitCommand	;0xE6 - invalid
	bra	WaitCommand	;0xE7 - invalid
	bra	WaitCommand	;0xE8 - invalid
	bra	WaitCommand	;0xE9 - invalid
	bra	WaitCommand	;0xEA - invalid
	bra	WaitCommand	;0xEB - invalid
	bra	WaitCommand	;0xEC - invalid
	bra	WaitCommand	;0xED - invalid
	bra	WaitCommand	;0xEE - invalid
	bra	WaitCommand	;0xEF - invalid

HwConfigNoDrive
	movlb	30		;Set signals for no drive:
	bsf	CLC2GLS2,6	;Set !DRVIN high
	bcf	CLC1GLS2,6	;Set SUPERDRIVE low
	bcf	CLC1GLS2,7	;Set MFMMODE low
	bsf	CLC2GLS0,6	;Set SIDES high
	bsf	CLC2GLS2,7	;Set PRESENT/!HD high
	bsf	FLAGS,NDIRTN	;Set !DIRTN high
	bra	WaitCommand	;Done

HwConfig400k
	movlb	30		;Set signals for 400k drive:
	bcf	CLC2GLS2,6	;Set !DRVIN low
	bcf	CLC1GLS2,6	;Set SUPERDRIVE low
	bcf	CLC1GLS2,7	;Set MFMMODE low
	bcf	CLC2GLS0,6	;Set SIDES low
	bcf	CLC2GLS2,7	;Set PRESENT/!HD low
	bsf	FLAGS,NDIRTN	;Set !DIRTN high
	clrf	TRACK		;Select track zero
	bra	WaitCommand	;Done

HwConfig800k
	movlb	30		;Set signals for 800k drive:
	bcf	CLC2GLS2,6	;Set !DRVIN low
	bcf	CLC1GLS2,6	;Set SUPERDRIVE low
	bcf	CLC1GLS2,7	;Set MFMMODE low
	bsf	CLC2GLS0,6	;Set SIDES high
	bsf	CLC2GLS2,7	;Set PRESENT/!HD (actually REVISED) high
	bsf	FLAGS,NDIRTN	;Set !DIRTN high
	clrf	TRACK		;Select track zero
	bra	WaitCommand	;Done

HwConfigSuper
	movlb	30		;Set signals for superdrive:
	bcf	CLC2GLS2,6	;Set !DRVIN low
	bsf	CLC1GLS2,6	;Set SUPERDRIVE high
	bcf	CLC1GLS2,7	;Set MFMMODE low
	bsf	CLC2GLS0,6	;Set SIDES high
	bcf	CLC2GLS2,7	;Set PRESENT/!HD low
	bsf	FLAGS,NDIRTN	;Set !DIRTN high
	clrf	TRACK		;Select track zero
	bra	WaitCommand	;Done

InsertDiskHdRo
InsertDiskHdRw
InsertDiskEject
	movlb	30		;Set signals for HD disk (or no disk):
	btfsc	CLC1GLS2,6	;If SUPERDRIVE is high, set PRESENT/!HD low,
	bcf	CLC2GLS2,7	; else leave it alone
	bra	WaitCommand	;Done

InsertDiskDdRo
InsertDiskDdRw
	movlb	30		;Set signals for DD disk:
	btfsc	CLC1GLS2,6	;If SUPERDRIVE is high, set PRESENT/!HD high,
	bsf	CLC2GLS2,7	; else leave it alone
	bra	WaitCommand	;Done

DataModeAutoGcr
	call	SetupForGcr	;Setup for GCR
	movlw	0xFD		;Set state to default
	movwf	X0		; "
DMAGcr0	call	FeatherOrUart	;003-029 Feather tachometer or service the UART
	DNOP			;030-031
	nop			;032
DMAGcr1	call	GetQueueLength	;033-047 Set/clear CTS and check if queue empty
	sublw	3		;048 If the queue length is >= 4, skip ahead to
	btfss	STATUS,C	;049  handle a group of bytes, else proceed to
	bra	DMAGcr2		;050(-051)  output zero and wait for more bytes
	call	ServiceUart	;051-063 Service the UART
	DNOP			;064-065
	call	ServiceUart	;066-078 Service the UART
	DNOP			;079-080
	call	ServiceUart	;081-093 Service the UART
	DNOP			;094-095
	call	ServiceUart	;096-108 Service the UART
	DNOP			;109-110
	call	ServiceUart	;111-123 Service the UART
	nop			;124
	movlb	4		;125 Write a zero byte to the SSP buffer after
	bcf	SSPCON1,SSPEN	;126  resetting the SSP to abort any
	bsf	SSPCON1,SSPEN	;127  transmission in progress
	clrf	SSP1BUF		;000  "
	bra	DMAGcr0		;001-002 Loop
DMAGcr2	movf	X0,W		;052 If state is -3, skip ahead to look for 0xD5
	xorlw	0xFD		;053  0xAA 0x96/0xAD patterns and otherwise
	btfsc	STATUS,Z	;054  treat next byte literally
	bra	DMAGcr3		;055(-056)  "
	xorlw	0xFE ^ 0xFD	;056 If state is -2, skip ahead to take next
	btfsc	STATUS,Z	;057  four bytes as the rest of the address mark
	bra	DMAGcr8		;058(-059)  "
	movlw	B'00000011'	;059 Initialize high-bits byte
	movwf	X1		;060  "
	lslf	INDF0,W		;061 Push high bits of first byte of trio into
	rlf	X1,F		;062  high-bits byte
	lslf	WREG,W		;063  "
	rlf	X1,F		;064  "
	incf	FSR0L,F		;065 Push high bits of second byte of trio into
	lslf	INDF0,W		;066  high-bits byte
	rlf	X1,F		;067  "
	lslf	WREG,W		;068  "
	rlf	X1,F		;069  "
	incf	FSR0L,F		;070 Push high bits of third byte of trio into
	movf	X0,W		;071  high-bits byte unless this is the final
	bcf	STATUS,C	;072  duo (not trio), in which case push two
	btfss	STATUS,Z	;073  zeroes instead
	lslf	INDF0,W		;074  "
	rlf	X1,F		;075  "
	lslf	WREG,W		;076  "
	rlf	X1,W		;077  "
	callw			;078-081 Translate from a GCR nibble into an IWM
	movwf	X1		;082  byte
	decf	FSR0L,F		;083 Rewind pointer to beginning of trio (or
	decf	FSR0L,F		;084  duo)
	call	ServiceUart	;085-097 Service the UART
	call	ServiceUart	;098-110 Service the UART
	call	ServiceUart	;111-123 Service the UART
	movf	X1,W		;124 Write the high-bits byte to the SSP buffer
	movlb	4		;125  after resetting the SSP to abort any
	bcf	SSPCON1,SSPEN	;126  transmission in progress
	bsf	SSPCON1,SSPEN	;127  "
	movwf	SSP1BUF		;000  "
	call	FeatherOrUart	;001-027 Feather tachometer or service the UART
	call	GetQueueLength	;028-042 Set/clear CTS
	call	ServiceUart	;043-055 Service the UART
	DNOP			;056-057
	call	ServiceUart	;058-070 Service the UART
	DNOP			;071-072
	call	ServiceUart	;073-085 Service the UART
	DNOP			;086-087
	call	ServiceUart	;088-100 Service the UART
	DNOP			;101-102
	call	ServiceUart	;103-115 Service the UART
	DNOP			;116-117
	movf	INDF0,W		;118 Translate the first byte of the trio from a
	iorlw	B'11000000'	;119  GCR nibble into an IWM byte
	callw			;120-123  "
	incf	FSR0L,F		;124 Advance to the second byte of the trio
	movlb	4		;125 Write the first IWM byte of the trio to the
	bcf	SSPCON1,SSPEN	;126  SSP buffer after resetting the SSP to
	bsf	SSPCON1,SSPEN	;127  abort any transmission in progress
	movwf	SSP1BUF		;000  "
	call	FeatherOrUart	;001-027 Feather tachometer or service the UART
	call	GetQueueLength	;028-042 Set/clear CTS
	call	ServiceUart	;043-055 Service the UART
	DNOP			;056-057
	call	ServiceUart	;058-070 Service the UART
	DNOP			;071-072
	call	ServiceUart	;073-085 Service the UART
	DNOP			;086-087
	call	ServiceUart	;088-100 Service the UART
	DNOP			;101-102
	call	ServiceUart	;103-115 Service the UART
	DNOP			;116-117
	movf	INDF0,W		;118 Translate the second byte of the trio from
	iorlw	B'11000000'	;119  a GCR nibble into an IWM byte
	callw			;120-123  "
	incf	FSR0L,F		;124 Advance to the third byte of the trio
	movlb	4		;125 Write the second IWM byte of the trio to
	bcf	SSPCON1,SSPEN	;126  the SSP buffer after resetting the SSP to
	bsf	SSPCON1,SSPEN	;127  abort any transmission in progress
	movwf	SSP1BUF		;000  "
	call	FeatherOrUart	;001-027 Feather tachometer or service the UART
	decf	X0,F		;028 Decrement the trio count
	incf	X0,W		;029 If it was zero before being decremented, it
	btfsc	STATUS,Z	;030  was a duo and we should return above
	bra	DMAGcr1		;031(-32)  "
	xorlw	B'11111111'	;032 If it was -1 before being decremented, this
	btfsc	STATUS,Z	;033  is the checksum trio and we should return
	movlw	0xFD		;034  to looking for 0xD5 0xAA sequences after
	btfsc	STATUS,Z	;035  it
	movwf	X0		;036  "
	call	GetQueueLength	;037-051 Set/clear CTS
	call	ServiceUart	;052-064 Service the UART
	call	ServiceUart	;065-077 Service the UART
	call	ServiceUart	;078-090 Service the UART
	call	ServiceUart	;091-103 Service the UART
	call	ServiceUart	;104-116 Service the UART
	nop			;117
	movf	INDF0,W		;118 Translate the third byte of the trio from
	iorlw	B'11000000'	;119  a GCR nibble into an IWM byte
	callw			;120-123  "
	incf	FSR0L,F		;124 Advance to the next byte
	movlb	4		;125 Write the third IWM byte of the trio to
	bcf	SSPCON1,SSPEN	;126  the SSP buffer after resetting the SSP to
	bsf	SSPCON1,SSPEN	;127  abort any transmission in progress
	movwf	SSP1BUF		;000  "
	bra	DMAGcr0		;001-002 Loop
DMAGcr3	movf	INDF0,W		;057 If the byte under the pointer is an 0xD5,
	xorlw	0xD5		;058  it may be part of a sequence; if not, skip
	btfss	STATUS,Z	;059  ahead to just output it as an IWM byte
	bra	DMAGcr4		;060(-061)  "
	incf	FSR0L,F		;061 If the next byte after the 0xD5 is an 0xAA,
	movf	INDF0,W		;062  it may be part of a sequence; if not, skip
	xorlw	0xAA		;062  ahead to just output the first as an IWM
	btfss	STATUS,Z	;063  byte
	bra	DMAGcr5		;064(-065)  "
	incf	FSR0L,F		;065 If the next byte after the 0xD5 0xAA is an
	movf	INDF0,W		;066  0x96, skip ahead to treat the next five
	xorlw	0x96		;067  bytes as an address mark
	btfsc	STATUS,Z	;068  "
	bra	DMAGcr7		;069(-070)  "
	xorlw	0xAD ^ 0x96	;070 If the next byte after the 0xD5 0xAA is an
	btfsc	STATUS,Z	;071  0xAD, skip ahead to treat the next 516
	bra	DMAGcr7		;072(-073)  bytes as a data block
	decf	FSR0L,F		;073 This was not a known 0xD5 0xAA sequence, so
	decf	FSR0L,F		;074  rewind the pointer
	DNOP			;075-076
	nop			;077
	bra	DMAGcr6		;078-079 Branch ahead
DMAGcr4	incf	FSR0L,F		;062 Advance and wrap the pointer to compensate
	DNOP			;063-064
	nop			;065
DMAGcr5	decf	FSR0L,F		;066 Regress and wrap the pointer to compensate
	call	ServiceUart	;067-079 Service the UART
DMAGcr6	call	ServiceUart	;080-092 Service the UART
	DNOP			;093-094
	call	ServiceUart	;095-107 Service the UART
	DNOP			;108-109
	call	ServiceUart	;110-122 Service the UART
	movf	INDF0,W		;123 Get the byte to be sent as a raw IWM byte
	incf	FSR0L,F		;124 Advance and wrap the pointer
	movlb	4		;125 Write the raw IWM byte to the SSP buffer
	bcf	SSPCON1,SSPEN	;126  after resetting the SSP to abort any
	bsf	SSPCON1,SSPEN	;127  transmission in progress
	movwf	SSP1BUF		;000  "
	bra	DMAGcr0		;001-002 Loop
DMAGcr7	call	ServiceUart	;071-083 Service the UART
	call	ServiceUart	;084-096 Service the UART
	nop			;097
	call	ServiceUart	;098-110 Service the UART
	call	ServiceUart	;111-123 Service the UART
	movlw	0xD5		;124 Write the 0xD5 byte to the SSP buffer after
	movlb	4		;125  resetting the SSP to abort any
	bcf	SSPCON1,SSPEN	;126  transmission in progress
	bsf	SSPCON1,SSPEN	;127  "
	movwf	SSP1BUF		;000  "
	call	FeatherOrUart	;001-027 Feather tachometer or service the UART
	call	GetQueueLength	;028-042 Set/clear CTS
	call	ServiceUart	;043-055 Service the UART
	nop			;056
	call	ServiceUart	;057-069 Service the UART
	call	ServiceUart	;070-082 Service the UART
	nop			;083
	call	ServiceUart	;084-096 Service the UART
	call	ServiceUart	;097-109 Service the UART
	nop			;110
	call	ServiceUart	;111-123 Service the UART
	movlw	0xAA		;124 Write the 0xAA byte to the SSP buffer after
	movlb	4		;125  resetting the SSP to abort any
	bcf	SSPCON1,SSPEN	;126  transmission in progress
	bsf	SSPCON1,SSPEN	;127  "
	movwf	SSP1BUF		;000  "
	call	FeatherOrUart	;001-027 Feather tachometer or service the UART
	call	GetQueueLength	;028-042 Set/clear CTS
	call	ServiceUart	;043-055 Service the UART
	nop			;056
	call	ServiceUart	;057-069 Service the UART
	call	ServiceUart	;070-082 Service the UART
	nop			;083
	call	ServiceUart	;084-096 Service the UART
	call	ServiceUart	;097-109 Service the UART
	nop			;110
	call	ServiceUart	;111-123 Service the UART
	movf	INDF0,W		;124 Write the third byte of the 0xD5 0xAA
	movlb	4		;125  sequence to the SSP buffer after resetting
	bcf	SSPCON1,SSPEN	;126  the SSP to abort any transmission in
	bsf	SSPCON1,SSPEN	;127  progress
	movwf	SSP1BUF		;000  "
	call	FeatherOrUart	;001-027 Feather tachometer or service the UART
	call	GetQueueLength	;028-042 Set/clear CTS
	movf	INDF0,W		;043 If this is an address mark, set the state
	xorlw	0x96		;044  so the next four bytes are treated as GCR
	movlw	174		;045  nibbles; if it's a data mark, set the
	btfsc	STATUS,Z	;046  state so the next 174 trios and a duo and
	movlw	0xFE		;047  a trio are crammed into GCR nibbles
	movwf	X0		;048  "
	incf	FSR0L,F		;049 Advance and wrap the pointer
	nop			;050
	call	ServiceUart	;051-063 Service the UART
	call	ServiceUart	;064-076 Service the UART
	call	ServiceUart	;077-089 Service the UART
	call	ServiceUart	;090-102 Service the UART
	call	ServiceUart	;103-115 Service the UART
	movlw	4		;116 Set X1 to the count of remaining address
	movwf	X1		;117  mark bytes
	movf	INDF0,W		;118 Translate the fourth byte in the sequence
	iorlw	B'11000000'	;119  (which is either the first byte of an
	callw			;120-123  address mark or the sector byte in a
	incf	FSR0L,F		;124  data mark) from a GCR nibble into an IWM
	movlb	4		;125  byte, advance and wrap the pointer, then
	bcf	SSPCON1,SSPEN	;126  write the byte to the SSP buffer after
	bsf	SSPCON1,SSPEN	;127  resetting the SSP to abort any
	movwf	SSP1BUF		;000  transmission in progress
	bra	DMAGcr0		;001-002 Loop
DMAGcr8	call	ServiceUart	;060-072 Service the UART
	DNOP			;073-074
	call	ServiceUart	;075-087 Service the UART
	DNOP			;088-089
	call	ServiceUart	;090-102 Service the UART
	DNOP			;103-104
	call	ServiceUart	;105-117 Service the UART
	movf	INDF0,W		;118 Translate the next byte in the address mark
	iorlw	B'11000000'	;119  from a GCR nibble into an IWM byte
	callw			;120-123  "
	incf	FSR0L,F		;124 Advance and wrap the pointer
	movlb	4		;125 Write the byte to the SSP buffer after
	bcf	SSPCON1,SSPEN	;126  resetting the SSP to abort any
	bsf	SSPCON1,SSPEN	;127  transmission in progress
	movwf	SSP1BUF		;000  "
	call	FeatherOrUart	;001-027 Feather tachometer or service the UART
	nop			;028
	decf	X1,F		;029 If that was the fifth address mark byte,
	btfsc	STATUS,Z	;030  rejoin the loop up top
	bra	DMAGcr1		;031(-032)  "
	call	GetQueueLength	;032-046 Set/clear CTS
	DELAY	3		;047-055
	movlw	0xFD		;056 Make sure mode is set back to normal for
	movwf	X0		;057  when we return from this handler
	bra	DMAGcr8		;058-059 Loop to handle the next byte

DataModeRawGcr
	call	SetupForGcr	;Setup for GCR
	movlb	8		;Set up Timer4 so ADC auto-reads at the right
	movlw	107		; time
	movwf	TMR4		; "
DMRGcr0	call	GetQueueLength	;034-048 Set/clear CTS and check if queue empty
	btfss	STATUS,Z	;049 If the queue is not empty, pop a byte off
	moviw	FSR0++		;050  and advance and wrap the pointer, else act
	bcf	FSR0H,0		;051  as though a zero was popped off the queue
	lslf	WREG,W		;052 Shift MSb out of byte and into carry
	movlb	8		;053 Switch bank so we can access Timer6
	rlf	X0,F		;054 Rotate 1st bit into the SR followed by a 0
	lslf	X0,F		;055  so SR is of the form x0x0x0x0, clear carry
	btfsc	X0,3		;056 If second data bit in the SR is a 1, set
	bsf	STATUS,C	;057  carry to rotate that bit into output byte
	btfsc	STATUS,Z	;058 If the SR is all 0s, inject a pseudorandom
	lsrf	TMR6,F		;059  bit by rotating LSb of Timer6 into carry
	rlf	WREG,W		;060 Rotate bit into output
	rlf	X0,F		;061 Rotate next bit into the SR followed by a 0
	lslf	X0,F		;062  so SR is of the form x0x0x0x0, clear carry
	btfsc	X0,3		;063 If second data bit in the SR is a 1, set
	bsf	STATUS,C	;064  carry to rotate that bit into output byte
	btfsc	STATUS,Z	;065 If the SR is all 0s, inject a pseudorandom
	lsrf	TMR6,F		;066  bit by rotating LSb of Timer6 into carry
	rlf	WREG,W		;067 Rotate bit into output
	rlf	X0,F		;068 Rotate next bit into the SR followed by a 0
	lslf	X0,F		;069  so SR is of the form x0x0x0x0, clear carry
	btfsc	X0,3		;070 If second data bit in the SR is a 1, set
	bsf	STATUS,C	;071  carry to rotate that bit into output byte
	btfsc	STATUS,Z	;072 If the SR is all 0s, inject a pseudorandom
	lsrf	TMR6,F		;073  bit by rotating LSb of Timer6 into carry
	rlf	WREG,W		;074 Rotate bit into output
	rlf	X0,F		;075 Rotate next bit into the SR followed by a 0
	lslf	X0,F		;076  so SR is of the form x0x0x0x0, clear carry
	btfsc	X0,3		;077 If second data bit in the SR is a 1, set
	bsf	STATUS,C	;078  carry to rotate that bit into output byte
	btfsc	STATUS,Z	;079 If the SR is all 0s, inject a pseudorandom
	lsrf	TMR6,F		;080  bit by rotating LSb of Timer6 into carry
	movwf	X1		;081 Preserve W through call to service UART
	call	ServiceUart	;082-094 Service the UART
	movlb	8		;095 Switch bank so we can access Timer6
	rlf	X1,W		;096 Rotate bit into output (C was preserved)
	rlf	X0,F		;097 Rotate next bit into the SR followed by a 0
	lslf	X0,F		;098  so SR is of the form x0x0x0x0, clear carry
	btfsc	X0,3		;099 If second data bit in the SR is a 1, set
	bsf	STATUS,C	;100  carry to rotate that bit into output byte
	btfsc	STATUS,Z	;101 If the SR is all 0s, inject a pseudorandom
	lsrf	TMR6,F		;102  bit by rotating LSb of Timer6 into carry
	rlf	WREG,W		;103 Rotate bit into output
	rlf	X0,F		;104 Rotate next bit into the SR followed by a 0
	lslf	X0,F		;105  so SR is of the form x0x0x0x0, clear carry
	btfsc	X0,3		;106 If second data bit in the SR is a 1, set
	bsf	STATUS,C	;107  carry to rotate that bit into output byte
	btfsc	STATUS,Z	;108 If the SR is all 0s, inject a pseudorandom
	lsrf	TMR6,F		;109  bit by rotating LSb of Timer6 into carry
	rlf	WREG,W		;100 Rotate bit into output
	rlf	X0,F		;111 Rotate next bit into the SR followed by a 0
	lslf	X0,F		;112  so SR is of the form x0x0x0x0, clear carry
	btfsc	X0,3		;113 If second data bit in the SR is a 1, set
	bsf	STATUS,C	;114  carry to rotate that bit into output byte
	btfsc	STATUS,Z	;115 If the SR is all 0s, inject a pseudorandom
	lsrf	TMR6,F		;116  bit by rotating LSb of Timer6 into carry
	rlf	WREG,W		;117 Rotate bit into output
	rlf	X0,F		;118 Rotate last bit into the SR followed by a 0
	lslf	X0,F		;119  so SR is of the form x0x0x0x0, clear carry
	btfsc	X0,3		;120 If second data bit in the SR is a 1, set
	bsf	STATUS,C	;121  carry to rotate that bit into output byte
	btfsc	STATUS,Z	;122 If the SR is all 0s, inject a pseudorandom
	lsrf	TMR6,F		;123  bit by rotating LSb of Timer6 into carry
	rlf	WREG,W		;124 Rotate bit into output
	movlb	4		;125 Write noise-ified byte to the SSP buffer
	bcf	SSPCON1,SSPEN	;126  after resetting the SSP to abort any
	bsf	SSPCON1,SSPEN	;127  transmission in progress
	movwf	SSP1BUF		;000  "
	call	FeatherOrUart	;001-027 Feather tachometer or service the UART
	movlb	1		;028 XOR pseudorandom result from the ADC with
	movf	ADRESL,W	;029  Timer6 for next time
	movlb	8		;030  "
	xorwf	TMR6,F		;031  "
	bra	DMRGcr0		;032-033 Loop

DataModeAutoMfm
	call	SetupForMfm	;Setup for MFM
	clrf	X1		;Clear literal countdown
	clrf	X0		; "
	movlb	0		;Give the UART a chance to receive the first
	btfss	PIR1,RCIF	; data byte before giving up on it
	bra	$-1		; "
DMAMf00	call	ServiceUart	;03-15 Service the UART
	call	GetQueueLength	;16-30 Set/clear CTS and check if queue empty
	btfsc	STATUS,Z	;31 If queue is empty, we're out of data and can
	bra	DMAMf12		;32(-33)  only wait to return to command mode
	moviw	FSR0++		;33 Pop next byte off queue and advance and wrap
	bcf	FSR0H,0		;34  the pointer
	movwf	X2		;35 Save it for later use
	movf	X1,F		;36 If the literal countdown is on zero, this
	btfsc	STATUS,Z	;37  byte may be a special byte, so match to
	movf	X0,F		;38  find out which one, else skip ahead
	btfss	STATUS,Z	;39  "
	bra	DMAMf05		;40(-41)  "
	bcf	FLAGS,MFMLIT	;41 Flag that byte is not to be taken literally
	xorlw	0xEE		;42 If it's 0xEE, it signals that user wants an
	btfsc	STATUS,Z	;43  index pulse and an 0x4E gap byte
	bra	DMAMf06		;44(-45)  "
	xorlw	0xFB ^ 0xEE	;45 If it's 0xFB, the next 514 bytes are to be
	btfsc	STATUS,Z	;46  taken literally
	bra	DMAMf07		;47(-48)  "
	xorlw	0xFE ^ 0xFB	;48 If it's 0xFE, the next six bytes are to be
	btfsc	STATUS,Z	;49  taken literally
	bra	DMAMf08		;50(-51)  "
DMAMf01	swapf	X2,W		;51 Translate upper nibble of original byte into
	andlw	B'00001111'	;52  LUT index and convert it to an MFM byte
	iorlw	B'10010000'	;53  "
	callw			;54-57  "
DMAMf02	btfsc	FLAGS,LASTLSB	;58 If LSb of last byte was set, clear the MSb
	andlw	B'01111111'	;59  of the translated MFM byte
	bcf	FLAGS,LASTLSB	;60  "
	movlb	4		;61 Write MFM byte to the SSP buffer after
	bcf	SSPCON1,SSPEN	;62  resetting the SSP to abort any transmission
	bsf	SSPCON1,SSPEN	;63  in progress
	movwf	SSP1BUF		;00  "
	call	ServiceUart	;01-13 Service the UART
	btfsc	FLAGS,MFMLIT	;14 If the byte is to be taken literally, skip
	bra	DMAMf09		;15(-16)  ahead to skip the checks below
	movf	X2,W		;16 Check if the byte is an 0xC2 or an 0xA1,
	xorlw	0xC2		;17  these have to have a clock removed from
	btfsc	STATUS,Z	;18  their lower MFM byte
	bra	DMAMf10		;19(-20)  "
	xorlw	0xA1 ^ 0xC2	;20  "
	btfsc	STATUS,Z	;21  "
	bra	DMAMf11		;22(-23)  "
	call	ServiceUart	;23-35 Service the UART
	DNOP			;36-37
	nop			;38
	call	ServiceUart	;39-51 Service the UART
DMAMf03	movf	X2,W		;52 Translate lower nibble of original byte into
	andlw	B'00011111'	;53  LUT index and convert it to an MFM byte
	iorlw	B'10100000'	;54  "
	callw			;55-58  "
DMAMf04	btfsc	WREG,0		;59 If the LSb of this lower translated byte is
	bsf	FLAGS,LASTLSB	;60  set, record that for later use
	movlb	4		;61 Write MFM byte to the SSP buffer after
	bcf	SSPCON1,SSPEN	;62  resetting the SSP to abort any transmission
	bsf	SSPCON1,SSPEN	;63  in progress
	movwf	SSP1BUF		;00  "
	bra	DMAMf00		;01-02 Loop
DMAMf05	DNOP			;42-43
	DNOP			;44-45
	DNOP			;46-47
	bsf	FLAGS,MFMLIT	;48 Flag that byte is to be taken literally
	bra	DMAMf01		;49-50 Rejoin loop
DMAMf06	movlb	0		;46 Reset Timer1
	clrf	T1CON		;47  "
	clrf	TMR1H		;48  "
	clrf	TMR1L		;49  "
	bsf	T1CON,TMR1ON	;50  "
	movlb	5		;51 Set CCP1 to go high now and go low when
	movlw	B'00001001'	;52  2.048 ms elapse, as SetupForMfm prepared
	clrf	CCP1CON		;53  "
	movwf	CCP1CON		;54  "
	movlw	0x92		;55 Set up 0x4's MFM byte to go out
	bra	DMAMf02		;56-57 Rejoin loop
DMAMf07	movlw	0x02		;49 Set literal countdown to 514 so data block
	movwf	X1		;50  is taken literally
	movwf	X0		;51  "
	DNOP			;52-53
	nop			;54
	movlw	0x55		;55 Set up 0xF's MFM byte to go out
	bra	DMAMf02		;56-57 Rejoin loop
DMAMf08	clrf	X1		;52 Set literal countdown to 6 so address mark
	movlw	6		;53  is taken literally
	movwf	X0		;54  "
	movlw	0x55		;55 Set up 0xF's MFM byte to go out
	bra	DMAMf02		;56-57 Rejoin loop
DMAMf09	movf	X0,F		;17 Decrement literal byte counter
	btfsc	STATUS,Z	;18  "
	decf	X1,F		;19  "
	decf	X0,F		;20  "
	call	ServiceUart	;21-33 Service the UART
	DNOP			;34-35
	nop			;36
	call	ServiceUart	;37-49 Service the UART
	bra	DMAMf03		;50-51 Rejoin loop
DMAMf10	call	ServiceUart	;21-33 Service the UART
	DELAY	3		;34-42
	call	ServiceUart	;43-55 Service the UART
	movlw	0x24		;56 Set up 0x2's MFM byte with missing clock
	bra	DMAMf04		;57-58 Rejoin loop
DMAMf11	call	ServiceUart	;24-36 Service the UART
	DNOP			;37-38
	DNOP			;39-40
	DNOP			;41-42
	call	ServiceUart	;43-55 Service the UART
	movlw	0x89		;56 Set up 0x1's MFM byte with missing clock
	bra	DMAMf04		;57-58 Rejoin loop
DMAMf12	call	ServiceUart	;Data ran dry, so just spin and wait for a break
	bra	$-1		; character to return us to command mode


;;; Subprograms ;;;

ServiceUart
	movlb	0		;02 If the UART has no byte waiting, skip ahead
	btfss	PIR1,RCIF	;03  to pass over this section while keeping
	bra	SvUart1		;04(-05)  the timing constant
	movlb	3		;05 If there was a framing error, skip ahead to
	btfsc	RCSTA,FERR	;06  check whether it was a break character or
	bra	SvUart0		;07(-08)  an actual framing error
	movf	RCREG,W		;08 Get the byte from the UART
	movwi	FSR1++		;09 Push it onto the queue and advance and wrap
	bcf	FSR1H,0		;10  the pointer
	return			;11-12 Done
SvUart0	movf	RCREG,W		;09 If the framing error was not all zeroes, it
	btfss	STATUS,Z	;10  was a real framing error, clear it and
	return			;11-12  return without pushing onto the queue
	movlb	0		;If it was all zeroes, it was a break character,
	clrf	T1CON		; which means to return to command mode, so
	clrf	TMR1H		; first stop and clear Timer1 so !TACH/INDEX
	clrf	TMR1L		; signal stops moving
	movlb	2		;Make sure CTS is low (asserted) so host knows
	bcf	CTS_PORT,CTS_PIN; it's okay to send data
	movlb	31		;Patch the callstack and return to await a
	movlw	high WaitCommand; command
	movwf	TOSH		; "
	movlw	low WaitCommand	; "
	movwf	TOSL		; "
	return			; "
SvUart1	DNOP			;06-07
	DNOP			;08-09
	nop			;10
	return			;11-12 Done

GetQueueLength
	movf	FSR0L,W		;02 Reckon how many bytes are in the queue
	subwf	FSR1L,W		;03  "
	movlb	2		;04 If the result is < 64, make sure that CTS
	btfss	WREG,7		;05  pin is asserted (low) so host sends us
	btfsc	WREG,6		;06  data
	bra	GQLeng0		;07  "
	bcf	CTS_PORT,CTS_PIN;08  "
GQLeng0	btfsc	WREG,7		;09 If the result is >= 192, make sure that CTS
	btfss	WREG,6		;10  pin is unasserted (high) so host holds off
	bra	GQLeng1		;11  sending us data
	bsf	CTS_PORT,CTS_PIN;12  "
GQLeng1	return			;13-14 Done

FeatherOrUart
	incf	TACHFCL,F	;02 Increment the tachometer feather count-up
	btfsc	STATUS,Z	;03  timer
	incf	TACHFCH,F	;04  "
	movlb	0		;05 If the tachometer signal has not recently
	btfss	PIR1,CCP1IF	;06  inverted, service UART instead
	bra	CTFeat0		;07(-08)  "
	bcf	PIR1,CCP1IF	;08 Clear the interrupt
	movlw	TACHFCV		;09 If the tachometer feather count-up timer is
	subwf	TACHFCH,W	;10  not yet at its limit, skip ahead to service
	btfss	STATUS,C	;11  the UART a second time
	bra	CTFeat1		;12(-13)  "
	movwf	TACHFCH		;13 Set feather count-up timer for next time
	movf	TACHFSH,W	;14 Swap TACHFSH:L with CCPR2H:L to feather the
	movlb	5		;15  tachometer signal
	xorwf	CCPR2H,F	;16  "
	xorwf	CCPR2H,W	;17  "
	xorwf	CCPR2H,F	;18  "
	movwf	TACHFSH		;19  "
	movf	TACHFSL,W	;20  "
	xorwf	CCPR2L,F	;21  "
	xorwf	CCPR2L,W	;22  "
	xorwf	CCPR2L,F	;23  "
	movwf	TACHFSL		;24  "
	return			;25-26 Done
CTFeat0	DNOP			;09-10
	DNOP			;11-12
	nop			;13
CTFeat1	bra	ServiceUart	;14(-26)

SetupForGcr
	clrf	FSR1L		;Empty queue
	clrf	FSR0L		; "
	movlb	4		;Configure SSP to operate at 500 kHz
	movlw	15		; "
	movwf	SSP1ADD		; "
	movlb	0		;Stop and clear Timer1 so we don't have any
	clrf	T1CON		; unexpected inverts or resets
	clrf	TMR1H		; "
	clrf	TMR1L		; "
	movlb	5		;Set CCP1 to invert its output whenever Timer1
	clrf	CCPR1H		; equals 0x0001 (right after it resets)
	movlw	1		; TODO can it be zero??
	movwf	CCPR1L		; "
	clrf	CCP1CON		; "
	movlw	B'00000010'	; "
	movwf	CCP1CON		; "
	swapf	TRACK,W		;Set CCP2 to reset Timer1 at a point appropriate
	andlw	B'00000111'	; to the drive rotation speed we want to imitate
	call	StFGcr0		; based on the current track number (see LUTs
	movwf	CCPR2H		; below and associated constants above)
	swapf	TRACK,W		; "
	andlw	B'00000111'	; "
	call	StFGcr1		; "
	movwf	CCPR2L		; "
	clrf	CCP2CON		; "
	movlw	B'00001011'	; "
	movwf	CCP2CON		; "
	swapf	TRACK,W		;Set the swap value for CCP2 in a similar manner
	andlw	B'00000111'	; to the above
	call	StFGcr2		; "
	movwf	TACHFSH		; "
	swapf	TRACK,W		; "
	andlw	B'00000111'	; "
	call	StFGcr3		; "
	movwf	TACHFSL		; "
	movlb	0		;Start Timer1 again
	bsf	T1CON,TMR1ON	; "
	movlb	30		;Set !READY low because step is ending
	bcf	CLC2GLS0,7	; "
	return			;Done
StFGcr0	brw
	retlw	high (2000000000 / (Z0RPM * (500 + RPMDEV)))
	retlw	high (2000000000 / (Z1RPM * (500 + RPMDEV)))
	retlw	high (2000000000 / (Z2RPM * (500 + RPMDEV)))
	retlw	high (2000000000 / (Z3RPM * (500 + RPMDEV)))
	retlw	high (2000000000 / (Z4RPM * (500 + RPMDEV)))
StFGcr1	brw
	retlw	low (2000000000 / (Z0RPM * (500 + RPMDEV)))
	retlw	low (2000000000 / (Z1RPM * (500 + RPMDEV)))
	retlw	low (2000000000 / (Z2RPM * (500 + RPMDEV)))
	retlw	low (2000000000 / (Z3RPM * (500 + RPMDEV)))
	retlw	low (2000000000 / (Z4RPM * (500 + RPMDEV)))
StFGcr2	brw
	retlw	high (2000000000 / (Z0RPM * (500 - RPMDEV)))
	retlw	high (2000000000 / (Z1RPM * (500 - RPMDEV)))
	retlw	high (2000000000 / (Z2RPM * (500 - RPMDEV)))
	retlw	high (2000000000 / (Z3RPM * (500 - RPMDEV)))
	retlw	high (2000000000 / (Z4RPM * (500 - RPMDEV)))
StFGcr3	brw
	retlw	low (2000000000 / (Z0RPM * (500 - RPMDEV)))
	retlw	low (2000000000 / (Z1RPM * (500 - RPMDEV)))
	retlw	low (2000000000 / (Z2RPM * (500 - RPMDEV)))
	retlw	low (2000000000 / (Z3RPM * (500 - RPMDEV)))
	retlw	low (2000000000 / (Z4RPM * (500 - RPMDEV)))
	dt	0xFF, 0xFF, 0xFF

SetupForMfm
	clrf	FSR1L		;Empty queue
	clrf	FSR0L		; "
	movlb	4		;Configure SSP to operate at 1 MHz
	movlw	7		; "
	movwf	SSP1ADD		; "
	movlb	0		;Stop and clear Timer1 so we don't have any
	clrf	T1CON		; unexpected inverts or resets
	clrf	TMR1H		; "
	clrf	TMR1L		; "
	movlb	5		;Turn off CCP2 so nothing resets Timer1, set up
	clrf	CCP2CON		; CCP1 so output is low for now but its register
	movlw	0x40		; in compare mode will trigger after 2.048 ms,
	movwf	CCPR1H		; this allows an index pulse to be set up using
	clrf	CCPR1L		; it
	clrf	CCP1CON		; "
	bsf	CCP1CON,3	; "
	movlb	30		;Set !READY low because step is ending
	bcf	CLC2GLS0,7	; "
	return			;Done


;;; Lookup Tables ;;;

	org	0x700

;LUT for converting raw read from command port into command
PortToCmd
	#include	transmitter_lut.inc	;Generated by pinout.py


	org	0x790

;LUT for converting byte to MFM clock/data nibble (high)
;Swap upper nibble into lower, set 0b1001xxxx
;Remember to clear MSB if LSB of last nibble was set
ByteToMfmHi
	dt	0xAA,0xA9,0xA4,0xA5,0x92,0x91,0x94,0x95
	dt	0x4A,0x49,0x44,0x45,0x52,0x51,0x54,0x55


	org	0x7A0

;LUT for converting byte to MFM clock/data nibble (low)
;Set 0b101xxxxx
;Remember to save LSB for next nibble
ByteToMfmLo
	dt	0xAA,0xA9,0xA4,0xA5,0x92,0x91,0x94,0x95
	dt	0x4A,0x49,0x44,0x45,0x52,0x51,0x54,0x55
	dt	0x2A,0x29,0x24,0x25,0x12,0x11,0x14,0x15
	dt	0x4A,0x49,0x44,0x45,0x52,0x51,0x54,0x55


	org	0x7C0

;LUT for converting 6-bit nibble to IWM byte
;Set 0b11xxxxxx
NibbleToIwm
	dt	0x96,0x97,0x9A,0x9B,0x9D,0x9E,0x9F,0xA6
	dt	0xA7,0xAB,0xAC,0xAD,0xAE,0xAF,0xB2,0xB3
	dt	0xB4,0xB5,0xB6,0xB7,0xB9,0xBA,0xBB,0xBC
	dt	0xBD,0xBE,0xBF,0xCB,0xCD,0xCE,0xCF,0xD3
	dt	0xD6,0xD7,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE
	dt	0xDF,0xE5,0xE6,0xE7,0xE9,0xEA,0xEB,0xEC
	dt	0xED,0xEE,0xEF,0xF2,0xF3,0xF4,0xF5,0xF6
	dt	0xF7,0xF9,0xFA,0xFB,0xFC,0xFD,0xFE,0xFF


;;; End of Program ;;;

	end
